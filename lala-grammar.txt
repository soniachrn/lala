grammar: Lala
version: 0.0.2


# TODO: forward declarations

# Types:
#
#   null     - ? - see no reason to have it
#   optional - ? - yes
#   function - ?
#
#   bool            false
#   int             0
#   uint            0
#   float           0
#   string          ''
#   array           []
#   map             {}
#   function
#   user-defined    ...
#   user-defined?   no-value

# Needed type casts:
#   uint <———> int <———> float
#   any type <———> string
#   user-defined <———> user-defined?

# Operators
#   or and       b-b
#   == !=        any matching type
#   >= <= > <    i-i   f-f   s-s
#   +            i-i   f-f   s-s
#   -            i-i   f-f
#   * /          i-i   f-f
#   %            i-i   f-i
#


# Parser

program         : top-statement* ;

top-statement   : declaration ;

# Declaration
declaration     : variable
                | function
                | structure
                | enum
                | statement
                ;
variable        : VAR? typed-id init? ;         # Bad here
init            : EQUAL expression ;
function        : FUNCTION ID parameters type-spec block? ;
parameters      : LPAREN (variable (COMMA variable)* COMMA?)? RPAREN ;
structure       : STRUCTURE ID LBRACE member* RBRACE ;
enum            : ENUM 
member          : predicate
                | typed-id
                ;
predicate       : PREDICATE expression ;
typed-id        : ID type-spec ;

# Statement
statement       : print
                | assert
                | assignment
                | if
                | while
                | do-while
                | for
                | function-call
                | CONTINUE
                | BREAK
                | RETURN
                | block
                ;
print           : PRINT expression ;
assert          : ASSERT expression ;
assignment      : postfix assign-op expression ;  # Compiler should force this postfix to end with one of: primary, subscript, member access
assign-op       : EQUAL
                | PLUS-EQUAL
                | MINUS-EQUAL
                | STAR-EQUAL
                | SLASH-EQUAL
                | PERCENT-EQUAL
                ;
if              : IF expression statement else? ;
else            : ELSE statement ;
while           : WHILE expression statement ;
do-while        : DO statement WHILE expression ;
for             : FOR ID IN expression statement ;
function-call   : postfix ;                                 # Compiler should force this postfix to end with a call.
block           : LBRACE declaration RBRACE ;

# Expression
expression      : and ;
or              : and (OR and)* ;
and             : comparison (AND comparison)* ;
comparison      : term (comparison-op term)? ;
comparison-op   : EQUAL-EQUAL
                | EXCLAMATION-EQUAL
                | GREATER-EQUAL
                | LESS-EQUAL
                | GREATER
                | LESS
                ;
term            : factor (term-op factor)* ;
term-op         : PLUS
                | MINUS
                ;
factor          : prefix (factor-op prefix)* ;
factor-op       : STAR
                | SLASH
                | PERCENT
                ;
prefix          : (MINUS | EXCLAMATION)? postfix ;
postfix         : primary postfixop* ;
postfixop       : DOT ID
                | call
                | LBRACKET expression RBRACKET
                | type-cast
                ;
call            : LPAREN (argument (COMMA argument)* COMMA?)? RPAREN ;
argument        : (ID EQUAL)? expression ;
primary         : TRUE
                | FALSE
                | INTEGER_VALUE
                | FLOAT_VALUE
                | STRING_VALUE
                | ID
                | array
                | map
                | LPAREN expression RPAREN
                ;
array           : LBRACKET (expression (COMMA expression)* COMMA?)? RBRACKET ;
map             : LBRACE (mapitem (COMMA mapitem)* COMMA?)? RBRACE;
mapitem         : expression COLON expression ;

# Utility
type-spec       : COLON type ;
type-cast       : COLON castable-type ;
type            : MUTABLE? immutable-type ;
immutable-type  : castable-type
                | BOOL
                | ID
                | LBRACKET type RBRACKET
                | LBRACE type COLON type RBRACE
                ;
castable-type   : INT
                | FLOAT
                | STRING
                ;


# Lexer

COLON           : : ;
COMMA           : , ;
DOT             : . ;
EQUAL           : = ;
EQUAL-EQUAL     : == ;
EXCLAMATION     : ! ;
EXCLAMATION-EQUAL: != ;
GREATER         : > ;
GREATER-EQUAL   : >= ;
LBRACE          : { ;
LBRACKET        : [ ;
LESS            : < ;
LESS-EQUAL      : <= ;
LPAREN          : ( ;
MINUS           : - ;
MINUS-EQUAL     : -= ;
PERCENT         : % ;
PERCENT-EQUAL   : %= ;
PLUS            : + ;
PLUS-EQUAL      : += ;
RBRACE          : } ;
RBRACKET        : ] ;
RPAREN          : ) ;
SLASH           : / ;
SLASH-EQUAL     : /= ;
STAR            : * ;
STAR-EQUAL      : *= ;

AND             : and ;
ASSERT          : assert ;
BOOL            : bool ;
BREAK           : break ;
CONTINUE        : continue ;
ELSE            : else ;
ENUM            : enum ;
FALSE           : false ;
FLOAT           : float ;
FOR             : for ;
FUNCTION        : function ;
IF              : if ;
IN              : in ;
INT             : int ;
MUTABLE         : mutable ;
OR              : or ;
PREDICATE       : predicate ;
PRINT           : print ;
RETURN          : return ;
STRING          : string ;
STRUCTURE       : structure ;
TRUE            : true ;
VAR             : var ;
WHILE           : while ;

INTEGER_VALUE       : ( ([1-9][0-9]*) | 0) ;
FLOAT_VALUE         : INTEGER_VALUE (\.[0-9]+) ;
STRING_VALUE        : \' ( [^\'\\] | \\ [trn\'\\] )* \' ;
ID                  : [a-zA-Z] ([a-zA-Z0-9\-]* [a-zA-Z0-9])? ;

# Ignore
COMMENT             : \| [^\n]* \n
                    | /- ([^-] | - [^/])* -/
                    ;
WHITESPACE          : [ \r\t\n]* ;

